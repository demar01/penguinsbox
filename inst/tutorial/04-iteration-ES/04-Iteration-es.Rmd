---
title: "Iteración"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Utiliza iteración para reducir duplicación en tu código.
---

<!-- Add JavaScript code for making the exercise code larger -->
<script language="JavaScript" src="js/exercise-font-size.js"></script>

```{r setup, include=FALSE}
# load packages-----------------------------------------------------------------

library(learnr)
library(tidyverse)
library(datos)

# set options for exercises and checking ---------------------------------------
pinguino_medidas <- tibble(
  pico = c(100,200,300),
  aletas= c(200,400,600),
  cabeza = c(400,800,1200))

# hide non-exercise code chunks ------------------------------------------------
tutorial_options(exercise.timelimit = 60)
knitr::opts_chunk$set(echo = FALSE)
```

## Introducción

```{r imagen-peng, fig.margin = TRUE, echo = FALSE, out.width = "100%", fig.cap="Unsplash: Andrea Gradilone"}
knitr::include_graphics("https://images.unsplash.com/photo-1506842605307-bbcbd9ea121f?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1267&q=80")
```

### Objetivos de aprendizaje

En este tutorial vas a aprender como resolver problemas de iteración en R. En concreto, vas a aprender a diferenciar como resolver este tipo de problemas con:

* Bucles
* Funciones preconstruidas para situaciones especificas como colMeans() 
* Funciones echas a medida con `purrr`

Al final de este tutorial habrás perfeccionado el uso de herramientas para hacer programación funcional en R.

## Iteracion con bucles

Imagina que tienes estos nuevos datos de pinguinos y quieres hacer la media aritmética de cada una de las columnas. 

```{r pinguino_medidas1, exercise = TRUE}
pinguino_medidas
```

```{r pinguino_medidas1-check}
" Estos son los datos que vas a explorar. pinguino_medidas es una dataset reducida con las observaciones de ...."
```


Puedes hacer la media de cada una de las columnas por separado:
```{r, echo=TRUE}
mean(pinguino_medidas$pico)
mean(pinguino_medidas$aletas)
mean(pinguino_medidas$cabeza)
```

Pero nos  repitiendo a nosotros mismos (recuerda la norma de oro de no copiar y pegar más de dos veces). Para evitar esto, podríamos usar un bucle for.

###

Recordemos que las 3 cosas que tiene un bucle son:

* `output`: La parte del código que asigna suficiente espacio para guardar el resultado. 
* `secuencia`: La parte del código que determina cuantas veces hay que ejecutar el bucle.
* `cuerpo`: La parte del código que hace el trabajo.

De esta manera podemos construir un bucle para iterar sobre los nuevos pinguinos.
```{r, echo=TRUE}
salida_media <- vector("double", ncol(pinguino_medidas)) 

for (i in seq_along(pinguino_medidas)) {    
    salida_media[[i]] <- mean(pinguino_medidas[[i]])}      
```

```{r, echo=TRUE}
salida_media
```

###

¿Cómo escribirías una función para calcular la mediana? ¡Inténtalo!

```{r ex1, exercise = TRUE}
salida_mediana <- vector("double", ncol(pinguino_medidas)) 

for (i in seq_along(pinguino_medidas)) {    
    salida_media[[i]] <- ___(pinguino_medidas[[i]])}      
salida_mediana
```

```{r ex1-solution}
salida_mediana <- vector("double", ncol(pinguino_medidas)) 

for (i in seq_along(pinguino_medidas)) {    
    salida_mediana[[i]] <- median(pinguino_medidas[[i]])}      
salida_mediana
```

### Vectorization

En lugar de escribir un bucle for, podemos hacer uso de vectorizacion en R y calcular la media de todas las columnas con la function predefinida `colMeans`:

```{r, echo=TRUE}
colMeans(pinguino_medidas)
```
Vemos que esta function se aplica a todas las columnas del dataset, y así no tenemos que utilizar un bucle for.


### Purrr

Podemos utilizar funciones del paquete purr para ejecutar este tipo de iteraciones, de manera sencilla y flexible.

Por ejemplo, podriamos calcular la media de todas las columnas:

```{r, echo=TRUE}
map(pinguino_medidas,mean)
```
Como vemos map aplica la functión `mean` a todas las columnas de pinguino_medidas.

```{r echo=FALSE, out.width = "70%"}
knitr::include_graphics("https://github.com/rstudio-education/primers/blob/master/iterate/map/www/images/map.png
")
```

Y esto puesto con el pipe
```{r, echo=TRUE}
pinguino_medidas %>% map(mean)
```


###

¿Qué tendrías que poner para calcular la mediana de cada una de las columnas?

```{r ex2, exercise = TRUE}
pinguino_medidas %>% map(___)

```

```{r ex2-solution}
pinguino_medidas %>% map(median)
```

```{r ex2-check}
 "Excellente. En este caso la media y la mediana tienen el mismo valor."
```

### Las funciones map

Como vemos esto retorna una lista. Hay una función para cada tipo de output:
* `map()`
* `map_dbl()`
* `map_chr()`
* `map_int()`
* `map_lgl()`

```{r, echo=TRUE}
pinguino_medidas %>% map_dbl(mean)
```

### Aplicar nuestra funccion. 

Imagina que escribes esta function media_armonica para aplicarla a los datos esta function media_armonica a los datos

media_armonica <- function(x){ 1/mean(1/x)}

###  

Para pasar esta function a map, tienes que seguir dos reglas. 

### Regla 1 - ~

En primer lugar, coloca `~` justo antes de tu función. Esto informa a  `map()` de que tiene que ejecutar la función dada.

Para cada elemento, haz `~harmonic_mean`

### Regla 2 - .x

En primer lugar, reemplaza  _el nombre de lo que haya que manipular_ with `.x` 


```{r, warning=FALSE}
map_dbl(pinguino_medidas, ~harmonic_mean(.x))
```

###  



```{r ex3-check}
"¡Muy bien! Vamos a ver Now let's cement our knowledge of `map()` by using it to solve a data wrangling challenge."
```


### Variaciones de map 


### List Columns 


